\section{三类方法间的比较}
关于在使用上述方法表示阴影时的附加困难，我们可以做个比较。
我们使用三个比较标准：
需要的额外数据存储空间，
需要的额外计算量，
所需的额外软件的实现难易。
在判定的时候，我们假设用扫描隐藏表面算法。\\
初看一眼，只有第二类和第三类算法看起来需要额外的数据存储。
两遍的方法要求表面沿着阴影边界分开，或者至少要在数据中包含阴影边界。
阴影多边形的方法要求存储可能的大量阴影多边形。
但是，这两类算法都不要求整个场景描述，用来进行隐藏表面计算。
背面表面和视场之外的数据可以被丢弃。
另一方面，第一类算法要求所有物体一直以原始数据的方式呈现，这样投影阴影边界才能在扫描期间计算出来。
所以，留给隐藏表面算法的后续步骤所需的临时空间就会严重缩减。
一定可以得出的结论是：两遍的方式需要最少的额外存储空间，阴影多边形的方式需要稍多一些的空间，而扫描时计算阴影的方式需要最多的空间。\\
假设仅使用外围来计算阴影边界总是更高效的，那么投射阴影多边形的方式似乎产生的必要计算的增加的是最少的。
一旦找到了外围边，那么阴影多边形的定义是很直观的。
通过利用阴影多边形的特殊性质，在扫描期间要做的额外计算量是最少的。
更进一步，另外两种方式要求方法遵循更低要求的增长律。
在扫描时计算阴影的方式要求额外的计算量，这是为了决定哪些表面可能投射阴影到其他表面上。并且通过操作物体空间数据，要求计算分割开有阴影区域和无阴影区域的线段。
Bouknight和Kelley概略地汇报说每次单个场景的阴影计算会扩大两倍的计算量。
反之，两遍的方式要求对于隐藏表面算法的额外解决方案。
但是，因为只要考虑外围边，第一遍可以简化。\\
对于投射阴影多边形的方式而言，所需的额外软件的复杂度同样是最低的。
第一类和第二类算法都要求完全新的软件。
不过，可以说，一旦一个合适的，针对于两遍的方式的隐藏表面算法出现了，那么第一遍所需的软件仅仅是第二遍所需软件的子集，所以并不需要额外的软件。\\
给定一个有可用扫描隐藏表面算法的情景，看起来阴影多边形的方式提供了最佳解决方案。
不过，从头开始的话，并没有一个清晰的最佳选择。
当然，通过实现任何一类的算法，也可以学到很多东西。